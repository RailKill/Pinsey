from PyQt4 import QtGui, QtCore
from pinsey.Constants import FONT_EMOJI, FONT_HEADLINE


class EmptyDict(dict):
    pass


class UserInformationWidgetStack:
    def __init__(self, user):
        """
                Generates a dictionary object containing widgets for user information. These widgets can be accessed by
                the following attributes: name_set, dob, distance, schools, jobs, bio.

                :param user:    Pynder User object whose information is to be generated.
                :type user:     pynder.models.user.User

                :Example:
                addWidget(UserInformationWidgetStack(user).name_set)
        """

        self.name_set = name_set(user.name, user.gender, user.age)  # User will definitely have a name attribute.
        "QLabel formatting of user's name, gender and age."

        self.dob = QtGui.QLabel('<b>Birthday: </b>' + user.birth_date.strftime("%B %d, %Y"))
        "QLabel containing user's date of birth."
        self.dob.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)

        self.distance = QtGui.QLabel('<b>Distance: </b>' + "{0:.2f}".format(user.distance_km) + 'km')
        "QLabel containing user's distance in km."
        self.distance.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)

        if user.schools:
            schools = ", ".join(str(x) for x in user.schools)
        else:
            schools = 'None.'
        self.schools = QtGui.QLabel('<b>Schools: </b>' + schools)
        "QLabel containing user's list of schools."
        self.schools.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)

        if user.jobs:
            jobs = ", ".join(str(x) for x in user.jobs)
        else:
            jobs = 'None.'
        self.jobs = QtGui.QLabel('<b>Occupation: </b>' + jobs)
        "QLabel containing user's list of jobs."
        self.jobs.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)

        self.bio = QtGui.QLabel()
        "QLabel containing user's biography."
        # Users that don't have a biography will not have this 'bio' attribute. Check if it exists before proceeding.
        if user.bio:
            self.bio.setText(user.bio)
        else:
            self.bio.setText('No biography found.')
        self.bio.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        self.bio.setFont(FONT_EMOJI)


def clickable(widget):
    class Filter(QtCore.QObject):
        clicked = QtCore.pyqtSignal()

        def eventFilter(self, obj, event):

            if obj == widget:
                if event.type() == QtCore.QEvent.MouseButtonRelease:
                    if obj.rect().contains(event.pos()):
                        self.clicked.emit()
                        # The developer can opt for .emit(obj) to get the object within the slot.
                        return True

            return False

    event_filter = Filter(widget)
    widget.installEventFilter(event_filter)
    return event_filter.clicked


def center(window):
    screen = QtGui.QDesktopWidget().screenGeometry()
    size = window.geometry()
    window.move((screen.width() / 2) - (size.width() / 2), (screen.height() / 2) - (size.height() / 2))


def horizontal_line():
    line = QtGui.QFrame()
    line.setFrameShadow(QtGui.QFrame.Sunken)
    line.setFrameShape(QtGui.QFrame.HLine)
    return line


def name_set(name, gender, age=0, banned=False):
    """
        Generates a QLabel name set that formats the name, gender and age nicely.

        :param name:    User's name.
        :type name:     str
        :param gender:  User's gender which should be 'male' or 'female' only.
        :type gender:   str
        :param age:     User's age.
        :type age:      int
        :param banned:  [Optional] Is the user banned or not?
        :type banned:   bool
        :return:        A QtGui.QLabel set that has the name, gender and age nicely formatted.
        :rtype:         QtGui.QLabel
    """
    age_string = '(' + str(age) + ')' if age > 0 else ''
    banned_string = '<span style="color: Red;"> [BANNED] </span>' if banned else ''

    if gender.lower() == 'female':
        gender_string = '<span style="color: DeepPink;"> ♀ </span>'
    else:
        gender_string = '<span style="color: DodgerBlue;"> ♂ </span>'
    name_string = name + gender_string + age_string + banned_string
    label_name = QtGui.QLabel(name_string)
    label_name.setFont(FONT_HEADLINE)
    label_name.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
    return label_name


def picture_grid(image_dict, image_size, number_of_photos):
    """
        Generates a picture grid that has exactly 3 columns and fits the images in image_dict based on
        number_of_photos. The first column will contain the main image with image_size, followed by the second
        and third columns containing the rest of the images.

        :param image_dict:          This dictionary of image data is generated by DownloadPhotosThread
                                    containing 'url' and 'data' attributes.
        :type image_dict:           dict
        :param image_size:          Size in pixels squared for the main image on the grid.
        :type image_size:           int
        :param number_of_photos:    Number of photos to fit into the grid.
        :type number_of_photos:     int
        :return:                    Generated QtGui.QGridLayout picture grid layout.
        :rtype:                     QtGui.QGridLayout
    """
    pp_layout = QtGui.QGridLayout()
    pp_layout.setSpacing(1)

    photos_half_amount = number_of_photos / 2
    photos_median = number_of_photos - photos_half_amount - 1
    median_section_count = 0
    last_section_count = 0

    for i in range(number_of_photos):
        image = QtGui.QImage()
        label = QtGui.QLabel()

        # Load profile photo data.
        label.setScaledContents(True)
        if i < len(image_dict):
            image.loadFromData(image_dict[i].data)
            label.setPixmap(QtGui.QPixmap(image))
        else:
            label.setText(str(i + 1))
            label.setAlignment(QtCore.Qt.AlignCenter)
            label.setStyleSheet('border: 1px solid')

        # Determine photo size for grid arrangement.
        size = image_size
        if i >= photos_half_amount:
            size /= photos_half_amount
            pp_layout.addWidget(label, last_section_count * photos_median, 2, photos_median, 1)
            last_section_count += 1
        elif i > 0:
            size /= photos_median
            pp_layout.addWidget(label, median_section_count * photos_half_amount, 1, photos_half_amount, 1)
            median_section_count += 1
        else:
            pp_layout.addWidget(label, 0, 0, photos_half_amount * photos_median, 1)
        label.setFixedWidth(size)
        label.setFixedHeight(size)

    return pp_layout
